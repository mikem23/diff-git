#!/usr/bin/python

import logging
from optparse import OptionParser
import os.path
import shutil
import sys
import subprocess
import tempfile

def _(args):
    """Stub function for translation"""
    return args

def get_options():
    """process options from command line"""

    usage = _("%prog [options] giturl1 giturl2")
    parser = OptionParser(usage=usage)
    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help=_("be more verbose"))
    parser.add_option("-q", "--quiet", action="store_true", default=False,
                      help=_("be less verbose"))
    parser.add_option("-d", "--debug", action="store_true", default=False,
                      help=_("show debug output"))
    # more opts ?
    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error("The command accepts exactly two arguments")
    options.repos = []
    for repo in args:
        if os.path.isdir(repo):
            repo = os.path.abspath(repo)
            options.repos.append(repo)

    return options


def log_cmd(cmd, logfile=None, fatal=True, **kwargs):
    """Run command and log output if able"""
    logger.debug('Running command: %s', ' '.join(cmd))
    if logfile:
        #kwargs.setdefault('stdout', sys.stdout)
        kwargs.setdefault('stderr', subprocess.STDOUT)
        kwargs.setdefault('close_fds', True)
    proc = subprocess.Popen(cmd, **kwargs)
    ret = proc.wait()
    if ret:
        if fatal:
            raise RuntimeError, "command failed: %r" % cmd
        #otherwise
        logger.debug("Command failed: %r" % cmd)
    return ret


def get_output(cmd, fatal=True, **kwargs):
     """Run command and log output if able"""
     logger.debug('Getting output from command: %s', ' '.join(cmd))
     kwargs['stdout'] = subprocess.PIPE
     kwargs.setdefault('close_fds', True)
     if 'stderr' in kwargs:
         # convenience values
         if kwargs['stderr'] == 'null':
             kwargs['stderr'] = file('/dev/null', 'w')
         elif kwargs['stderr'] == 'keep':
             kwargs['stderr'] = subprocess.STDOUT
     proc = subprocess.Popen(cmd, **kwargs)
     output = proc.communicate()[0]
     logger.debug("Command output was:\n%s", output)
     rv = proc.wait()
     if rv:
         logger.warn("Command failed: %r" % cmd)
         if fatal:
             raise CommandError, "command failed: %r" % cmd
     return output, rv



def main():
    heads = []
    for repo in options.repos:
        cmd = ['git', 'ls-remote', '--heads', repo]
        output, rv = get_output(cmd, stderr='null', fatal=True)
        rows = [ r.split(None, 1) for r in output.splitlines()]
        hdict = dict([(ref, sha) for (sha, ref) in rows])
        heads.append(hdict)
    common = [h for h in heads[1] if h in heads[0]]
    added = [h for h in heads[1] if h not in heads[0]]
    dropped = [h for h in heads[0] if h not in heads[1]]
    if added:
        logger.warning('Added %i heads:', len(added))
        for h in added:
            logger.warning('+ %s', h)
    if dropped:
        logger.warning('Dropped %i heads:', len(dropped))
        for h in dropped:
            logger.warning('- %s', h)
    changed = []
    if common:
        for h in common:
            if heads[0][h] != heads[1][h]:
                changed.append(h)
                logger.warning('Head %s differs:', h)
                logger.warning('  %s', heads[0][h])
                logger.warning('  -> %s', heads[1][h])
            else:
                logger.info('Branch %s matches', h)
    if changed:
        workdir = tempfile.mkdtemp()
        logger.debug('Using workdir: %s', workdir)
        log_cmd(['git', 'init', '-q'], cwd=workdir)
        for h in changed:
            if h.startswith('refs/heads/'):
                name = h[11:]
            else:
                logger.warning('Unexpected head ref format: %s', h)
                name = h
            for n, repo in enumerate(options.repos):
                cmd = ['git', 'fetch', '-q', '--depth=100', '--no-tags', repo,
                        '+%s:refs/repos/%i/%s' % (h, n, name)]
                #TODO depth config
                #TODO config for checking tags
                log_cmd(cmd, cwd=workdir)
            #check ancestry
            cmd = ['git', 'merge-base', '--is-ancestor',
                    'refs/repos/0/%s' % name, 'refs/repos/1/%s' % name]
            rv = log_cmd(cmd, cwd=workdir, fatal=False)
            if rv == 0:
                logger.warning('Head %s is fast-forwarded', h)
                # TODO - show log
                continue
            elif rv != 1:
                raise RuntimeError, 'git exited with status %i' % rv
            cmd = ['git', 'merge-base', '--is-ancestor',
                    'refs/repos/1/%s' % name, 'refs/repos/0/%s' % name]
            rv = log_cmd(cmd, cwd=workdir, fatal=False)
            if rv == 0:
                logger.warning('Head %s is rolled back', h)
                # TODO - show log
                continue
            elif rv != 1:
                raise RuntimeError, 'git exited with status %i' % rv
            logger.warning('Head %s has deviated', h)
        shutil.rmtree(workdir)


if __name__ == '__main__':
    options = get_options()
    logger = logging.getLogger("diff-git")
    if options.debug:
        log_level = logging.DEBUG
    elif options.verbose:
        log_level = logging.INFO
    elif options.quiet:
        log_level = logging.ERROR
    else:
        log_level = logging.WARNING
    logger.setLevel(log_level)
    handler = logging.StreamHandler(sys.stdout)
    log_fmt = ''
    handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    main()
